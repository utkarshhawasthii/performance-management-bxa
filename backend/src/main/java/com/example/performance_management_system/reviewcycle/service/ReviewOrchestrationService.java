package com.example.performance_management_system.reviewcycle.service;

import com.example.performance_management_system.common.enums.Role;
import com.example.performance_management_system.goal.model.Goal;
import com.example.performance_management_system.goal.repository.GoalRepository;
import com.example.performance_management_system.keyresult.model.KeyResult;
import com.example.performance_management_system.rating.model.Rating;
import com.example.performance_management_system.rating.model.RatingStatus;
import com.example.performance_management_system.rating.repository.RatingRepository;
import com.example.performance_management_system.review.model.Review;
import com.example.performance_management_system.review.repository.ReviewRepository;
import com.example.performance_management_system.review.service.ReviewService;
import com.example.performance_management_system.reviewcycle.model.ReviewCycle;
import com.example.performance_management_system.user.model.User;
import com.example.performance_management_system.user.repository.UserRepository;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ReviewOrchestrationService {

    private final UserRepository userRepository;
    private final RatingRepository ratingRepository;
    private final ReviewRepository reviewRepository;
    private final GoalRepository goalRepository;

    public ReviewOrchestrationService(
            UserRepository userRepository,
            RatingRepository ratingRepository,
            ReviewRepository reviewRepository,
            GoalRepository goalRepository
    ) {
        this.userRepository = userRepository;
        this.ratingRepository = ratingRepository;
        this.reviewRepository = reviewRepository;
        this.goalRepository = goalRepository;
    }
    @Transactional
    public void createReviewsForCycle(ReviewCycle cycle) {

        List<User> employees = userRepository.findByRole(Role.EMPLOYEE);

        for (User employee : employees) {

            // ðŸ”¥ SKIP employees without manager
            if (employee.getManagerId() == null) {
                continue;
            }

            boolean exists =
                    reviewRepository.existsByEmployeeIdAndReviewCycle(
                            employee.getId(),
                            cycle
                    );

            if (exists) {
                continue;
            }

            Review review = new Review();
            review.setEmployeeId(employee.getId());
            review.setManagerId(employee.getManagerId());
            review.setReviewCycle(cycle);

            reviewRepository.save(review);
        }
    }

    @Transactional
    public void generateRatingsForCycle(ReviewCycle cycle) {

        List<User> employees = userRepository.findByRole(Role.EMPLOYEE);

        for (User employee : employees) {

            boolean alreadyExists =
                    ratingRepository.existsByEmployeeIdAndPerformanceCycle(
                            employee.getId(),
                            cycle.getPerformanceCycle()
                    );

            if (alreadyExists) {
                continue; // ðŸ”¥ do not duplicate
            }

            double score = calculateInitialScore(employee.getId(), cycle);

            Rating rating = new Rating();
            rating.setEmployeeId(employee.getId());
            rating.setManagerId(employee.getManagerId());
            rating.setPerformanceCycle(cycle.getPerformanceCycle());
            rating.setScore(score);
            rating.setStatus(RatingStatus.DRAFT);
            rating.setManagerJustification("Auto-generated by system");

            ratingRepository.save(rating);
        }
    }

    private int calculateInitialScore(Long employeeId, ReviewCycle cycle) {

        List<Goal> goals =
                goalRepository.findByEmployeeIdAndPerformanceCycle_Id(
                        employeeId,
                        cycle.getPerformanceCycle().getId()
                );

        if (goals.isEmpty()) return 2;

        double totalProgress = 0;

        for (Goal goal : goals) {
            for (KeyResult kr : goal.getKeyResults()) {
                double progress =
                        (kr.getCurrentValue() / kr.getTargetValue()) * 100;
                totalProgress += Math.min(progress, 100);
            }
        }

        double avg = totalProgress / goals.size();

        if (avg >= 90) return 5;
        if (avg >= 75) return 4;
        if (avg >= 60) return 3;
        return 2;
    }



}

